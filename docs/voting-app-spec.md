Great, I’ll now draft a Cursor AI agent specification that builds a voting system as a Common Ground plugin. It will follow your provided MVP functional scope, adopt the Common Ground context/auth model, simulate real-time updates using react-query cache invalidation, and scaffold the UI to match your design example.

I’ll incorporate database table design, backend API shape, and React component scaffolding that respects the plugin architecture in the CGSamplePlugin repo and follows patterns from your existing advanced plugin.

I’ll get back to you shortly with the full specification and scaffold.


# Common Ground Voting Plugin Implementation Specification

## Overview and Key Features

This specification outlines a **lightweight voting system plugin** built for the Common Ground platform. It will be implemented as a modern Next.js application with a PostgreSQL backend, following the Common Ground plugin architecture and using the CGSamplePlugin boilerplate as a foundation. The plugin enables community members to submit posts and upvote them, similar to a content aggregator, while strictly relying on Common Ground’s context and authentication model for user identity. Key MVP features include:

* **Upvote Feed Page:** A page displays a list of user-submitted posts sorted by **most upvotes** (highest vote count first). The feed updates its order immediately when votes change.
* **Post Cards with Meta Data:** Each post is shown as a **card** containing the post title, a brief description/blurb, associated tags, the author’s name and profile icon, the time since it was posted (e.g. “8 hours ago”), the number of upvotes, the number of comments, and action icons (comment, share, bookmark). This provides at-a-glance information and interactions for each post.
* **Upvoting Interaction:** Logged-in users can upvote a post or remove their upvote (toggle). The upvote button is highlighted (e.g. orange color) when the user has upvoted that post, providing immediate visual feedback. Clicking the button again removes the vote. Vote counts update instantly after an action, and the UI reflects the change without a full page reload.
* **Real-Time Feed Updates:** After a vote, the feed re-sorts if necessary so that posts remain sorted by upvotes. This gives a real-time feel (simulated via fast data refetch and cache invalidation using React Query, rather than webSockets).
* **Authentication Gating:** Only authenticated Common Ground users can vote. If a user is not signed in (or if the plugin cannot detect a valid user context), the upvote action is disabled or prompts the user to sign in through Common Ground. No separate login system is used – we rely entirely on Common Ground’s user context and auth.
* **State Persistence:** A logged-in user’s voting state is preserved on page reload. If the user refreshes the page or returns later, posts they have upvoted remain indicated as upvoted (highlighted button), and the sorted order remains consistent. This is achieved by storing and fetching vote records for that user.
* **Responsive and Themed UI:** The interface is responsive for both desktop and mobile. It supports light and dark mode themes (toggleable), including a pleasant gradient background in each mode. All interactive elements are accessible via keyboard and screen-reader friendly.

The plugin is built with **Next.js (latest 13+ with React 18)** for the frontend and serverless API routes, **PostgreSQL** for persistent data, and **React Query** for client-side state management and caching. It utilizes the Common Ground Plugin API/library for secure communication with the parent platform and to obtain user/context information. By following the structure of the CGSamplePlugin and patterns from an existing mature plugin, we ensure our implementation aligns with Common Ground’s best practices for context, authentication, and integration.

## Database Schema

The plugin introduces a few tables in the PostgreSQL database to store users, posts, and votes. We design the schema to maintain relationships between Common Ground users and their posts/votes. A **users** table is included to track basic info of Common Ground users (keyed by the CG user ID) as they interact with the plugin, per the provided CG data model. Below are the core tables:

* **Users** – stores Common Ground user profiles who appear in posts or votes. Fields include:

  * `id` – primary key (auto-increment integer).
  * `cg_user_id` – the user’s unique ID from Common Ground (e.g. a UUID or handle) – this is indexed and kept unique, serving as the link to CG’s identity.
  * `display_name` – the user’s display name (as shown on Common Ground, e.g. “David Kim”).
  * `avatar_url` – URL or path to the user’s avatar image (if provided by Common Ground profile; can be null/empty if user has no avatar).
  * `created_at` – timestamp when this user record was first seen/created in our DB.
    *(The plugin may create or update a user row whenever a new Common Ground user appears – e.g., when someone new submits a post or votes. This local table caches profile info for quick access in UI. On each login or post submission, we can refresh the user’s name/avatar from the CG API to keep data current.)*

* **Posts** – stores the content that users submit to be voted on. Fields include:

  * `id` – primary key for the post (auto-increment integer).
  * `author_id` – foreign key reference to `users.id` for the post’s author (the Common Ground user who submitted the post). This establishes the relationship to the user table; we can join to get the author’s name or avatar.
  * `title` – text title of the post. (e.g. “Open Source Project: React Component Library”)
  * `content` – text content or description/blurb of the post. This can be a short paragraph giving more details. (From the UI, it appears as the subtitle text beneath the title.)
  * `tags` – array of text tags or categories associated with the post (e.g. `["Open Source", "React", "Components"]`). This could be implemented as a text array column or via a separate tags table; for simplicity, a text array or comma-separated string is used in MVP.
  * `upvote_count` – integer storing the number of upvotes the post has received. This can be updated whenever votes change (to avoid expensive count queries on each load), or alternatively computed via the votes table on the fly. In our MVP, we will update this count on each vote mutation for efficiency.
  * `comment_count` – integer count of comments on the post. (Comments functionality might be outside this MVP’s scope; this field is included to display a comment count on each post card. It can remain 0 or be integrated with a future comment system or Common Ground’s discussion threads.)
  * `created_at` – timestamp when the post was submitted. Used to show “time since posted” (e.g. “8 hours ago”), which the UI can compute relative to current time.
  * *(Additional fields like `updated_at` could be included if posts are editable, but not required for MVP.)*
    **Indexes & Constraints:** We index `upvote_count` (or will use an ORDER BY on an aggregate query) since we frequently sort by it. The `author_id` is a foreign key into `users(id)` (with ON DELETE CASCADE or RESTRICT to maintain referential integrity). The combination of `id` and `author_id` isn’t necessarily unique beyond `id` being PK. We ensure `title` length is reasonable and perhaps ensure non-null `title` and `author_id`. Tags could be normalized later if needed.

* **Votes** – stores each upvote action by a user on a post. This table enables many-to-many relationship between users and posts (a user can vote on many posts, a post can have many user votes). Fields include:

  * `id` – primary key for the vote record (auto-increment). (Alternatively, we could use a composite key of `user_id` and `post_id` instead of a surrogate ID, since a vote is uniquely identified by user+post. Using an `id` is convenient but optional.)
  * `user_id` – foreign key to `users.id` representing the user who cast the vote.
  * `post_id` – foreign key to `posts.id` representing the post that was upvoted.
  * `created_at` – timestamp when the vote was made (can be used for analytic or ordering if needed).
    **Constraints:** Enforce a uniqueness constraint on `(user_id, post_id)` so that a user can vote at most once per post (no duplicate votes). This uniqueness constraint allows the “toggle” behavior – if a user tries to vote again, we know they already have one. To remove a vote, we actually delete the record from this table. The foreign keys ensure votes cannot reference non-existent users or posts (with cascades so that if a post or user is removed, their votes are removed as well).

**Relationships:** In summary, `users` → `posts` is one-to-many (a user authors many posts), `users` → `votes` is one-to-many (a user’s many votes), and `posts` → `votes` is one-to-many (a post’s many votes). The `votes` table is the join that links users and posts many-to-many. We use the `upvote_count` in `posts` as a cached aggregate of votes for quick sorting. Alternatively, a SQL query could compute vote counts on the fly (e.g., via `COUNT(*)` on votes grouped by post) if we choose not to denormalize; however, updating a counter on each vote is straightforward and keeps read queries fast.

## API Endpoints and Data Flow

We will implement RESTful API routes (Next.js API routes) for retrieving the post feed and handling vote actions. All API endpoints will **respect Common Ground’s auth context** – meaning they will ensure the user is authenticated via Common Ground. The plugin uses Next.js’s built-in API routing (in the `app/api` directory) to create endpoints. Below are the primary routes, including their purpose, inputs, and outputs:

* **GET `/api/posts`** – *Fetch the list of posts (the feed).* This endpoint returns a JSON array of post objects, sorted by `upvote_count` in descending order (most upvoted first).

  * **Request:** No required body or query params for basic feed. Optionally, the client can include the current user’s ID (e.g. as a query parameter like `?userId=<cg_user_id>` or it may be derived from the session/context on the server) to personalize the response.
  * **Response:** JSON object containing an array of posts. Each post object includes its `id`, `title`, `blurb/content`, `tags`, `author` info, `upvote_count`, `comment_count`, `created_at` timestamp, etc. For example:

    ```json
    [
      {
        "id": 42,
        "title": "Open Source Project: React Component Library",
        "content": "Launching a new open-source React library focused on accessibility and performance...",
        "tags": ["Open Source", "React", "Components"],
        "author": { "id": 5, "display_name": "David Kim", "avatar_url": "<...>" },
        "upvote_count": 203,
        "comment_count": 67,
        "created_at": "2025-05-28T07:30:00Z",
        "userHasUpvoted": true
      },
      ...
    ]
    ```

    If the request is from an authenticated user, each post object will include a boolean flag (e.g. `userHasUpvoted`) indicating whether that user has an active vote on the post. This is computed by checking the `votes` table for a record with that post and the user’s ID. (Alternatively, the client could fetch the list of user’s votes separately, but for convenience we merge it here.) Unauthenticated requests will still get the list of posts, but without any `userHasUpvoted` flags (or all defaults false), and voting actions would be disabled on the UI side for such users.

    * **Authorization:** This endpoint can be accessed by anyone to read the feed. However, in practice, if a user is not logged in to Common Ground, they likely can’t even see the community plugin content (or if they can, they just can’t vote). No sensitive data is exposed here; it’s a public feed.

* **POST `/api/posts`** – *Submit a new post.* (Optional, if allowing users to add content in MVP.) This endpoint would allow an authenticated user to add a new post to the feed. It is not explicitly listed in the feature scope, but since posts are “user-submitted,” we anticipate a form for users to create posts.

  * **Request:** JSON body with the new post details: e.g. `{ "title": "...", "content": "...", "tags": ["tag1","tag2"] }`. The user’s identity is taken from the auth context (we do **not** allow overriding the author – the backend will infer the `author_id` from the logged-in user’s session or CG user ID).
  * **Response:** On success, returns a 201 Created status and the created post object (or at least its ID). The new post will start with `upvote_count = 0` (or 1 if we decide to auto-upvote the author’s own post) and `comment_count = 0`. This endpoint will enforce that the user is authenticated; if not, it returns 401 Unauthorized.
  * **Note:** This feature may be out-of-scope for the initial MVP if only viewing/voting is needed, but the database and UI support it if added. We would follow patterns from CGSamplePlugin for form handling and secure submission.

* **POST `/api/posts/{postId}/votes`** – *Upvote a post.* This endpoint is called when a user clicks the upvote button on a specific post. It will record a vote by the current user on the given post.

  * **Request:** The `{postId}` is part of the URL path. The body may be empty (all information needed is the post ID from the URL and the user from auth). The server determines the `user_id` from the session/CG context (so the client doesn’t need to send it explicitly, preventing spoofing).
  * **Response:** Returns 200 OK if the vote was successfully recorded. The response body could contain the updated vote count or the updated post object, though it’s not strictly necessary since the client will refetch the list. For example, it might return `{ "upvote_count": 128 }` for the new count. If the user has already upvoted that post (vote exists), the server might either return an error or simply ignore (idempotent). In our toggle design, the client should call DELETE for removal (below), so this POST should ideally error (409 Conflict) or no-op if a vote already exists.
  * **Authorization:** Requires a logged-in user. If no valid user session or token is present, returns 401. This ensures only authenticated Common Ground users can vote. The backend will verify the user’s identity via the plugin’s auth context (see **Auth Integration** below).

* **DELETE `/api/posts/{postId}/votes`** – *Remove (undo) an upvote.* This is the counterpart to the above, invoked when a user clicks to remove their vote (toggle off).

  * **Request:** `{postId}` in URL identifies which vote to remove. No body needed (or could optionally include the user, but again we derive user from session).
  * **Response:** Returns 200 OK if a vote was found and removed. If the user hadn’t actually voted before, it can return 404 or simply 200 with no change. The response might include the updated count (e.g. `{ "upvote_count": 127 }` after removing).
  * **Authorization:** Same as above – must be logged in. Otherwise 401.

  *Implementation details:* Upon POST, the server will insert a new record in the `votes` table (`user_id`, `post_id`), and increment the `upvote_count` in the `posts` table by 1 (e.g., via an UPDATE or database trigger). On DELETE, the server deletes the `votes` record and decrements the `upvote_count`. Both operations should be done atomically (within a transaction) to keep counts in sync with the votes records. We will also handle race conditions (e.g., if two upvote requests come in at once for the same post by the same user, the uniqueness constraint will prevent duplicates – we catch the error and handle gracefully). The API will send appropriate HTTP status codes for error cases (e.g., 400 if `postId` is invalid, 401 if not authenticated, etc.).

* **POST `/api/sign`** – *Request signing endpoint (part of Common Ground plugin security).* This is a special endpoint required by the Common Ground plugin architecture. The plugin’s frontend uses the Common Ground Plugin SDK to communicate with the parent platform via signed messages. Whenever the plugin needs to call a Common Ground backend API (for example, to fetch the current user’s profile or other community data), it will send a request payload to `/api/sign`. This endpoint will use the Common Ground host library (`@common-ground-dao/cg-plugin-lib-host`) to **cryptographically sign** the request using the plugin’s private key, and return the signed payload, which the frontend then forwards to Common Ground.

  * **Request:** The body contains the data to sign (typically an encoded request or challenge from the CG SDK). For example, the CG SDK might post something like `{ "request": "<payload>", "nonce": "...", ... }`.
  * **Response:** A JSON response containing the signed request and/or signature. For example: `{ "signedRequest": "...", "signature": "abc123..." }`. The Common Ground SDK then sends this along to the Common Ground backend to perform the authorized action.
  * This route is secured in that it should only accept requests from the plugin’s own front-end (we could check an auth token or the origin). It doesn’t require a user session specifically, since it’s signing on behalf of the plugin itself. It’s important for enabling the secure message-passing system of Common Ground. We will ensure to protect this route from external abuse (it should not sign arbitrary data for unauthorized callers).

In addition to the above, we might have other utility routes (for example, a route to fetch a single post’s details and comments if we had a detailed view, or an `/api/user` route to get the current user’s profile from our DB if needed). However, the core interactions are covered by the feed (GET posts) and vote toggling routes.

All API endpoints will be implemented within the Next.js app, likely under `src/app/api`. For example, `src/app/api/posts/route.ts` (for GET and POST dispatch based on method), `src/app/api/posts/[id]/votes/route.ts` (for handling vote toggling via different HTTP methods), and `src/app/api/sign/route.ts` for the signing logic. We will use Common Ground’s context to verify user identity on protected routes (e.g., checking that a session or token for a CG user exists before allowing POST/DELETE votes). Responses will typically be JSON. We will also integrate **React Query** on the client side to call these endpoints – details on that in the Frontend sections below.

## Frontend Components Architecture

The user interface is built with reusable React components, making the code modular and maintainable. The main components in this plugin include a **FeedList** (container for the list of posts), **PostCard** (displays an individual post’s info and actions), and **VoteButton** (the interactive upvote toggle). These components work together to provide the interactive feed. Below is an overview of each:

### FeedList Component

The `FeedList` is the high-level component that fetches and renders the list of posts. It is typically used on the main page (e.g., `pages/index.js` or `app/page.tsx` in Next.js). Key characteristics:

* **Data Fetching:** On mount, `FeedList` uses React Query’s `useQuery` hook to fetch the posts from the backend (`GET /api/posts`). It might use a query key like `['posts']` (and include the current user in the query key or fetch URL so that it returns user-specific vote info). The hook provides loading and error states which `FeedList` handles (e.g., show a loading spinner or message while posts load, and an error message if the fetch fails).
* **Rendering Posts:** Once data is fetched, `FeedList` maps over the array of posts and renders a `PostCard` for each entry. It passes down the post data as props to the `PostCard`. For example: `<PostCard key={post.id} post={post} currentUserId={currentUserId} />` (if needed, though the post object may already include whether current user voted).
* **Empty State:** If the list is empty (no posts), `FeedList` can render a placeholder message (e.g., “No posts yet. Be the first to submit one!”) to handle that scenario gracefully.
* **Styling/Layout:** `FeedList` could be a simple `<div>` or `<main>` element that wraps all `PostCard` components, possibly with some padding and a max-width to keep the feed centered. It might also include a heading or sort controls (like the “Sorted by Most Upvoted” toggle at the top).
* **React Query Integration:** `FeedList` defines the data fetching logic and also integrates with the voting mutations. For instance, it will use React Query’s query invalidation – when a vote is cast (in `VoteButton`), the success callback will trigger an invalidation of the `['posts']` query. This prompts `FeedList` to refetch the list, updating the UI with new vote counts and resorted order. If desired, `FeedList` can also set up polling or refetch-on-focus to keep data fresh (though not strictly required for MVP).

By separating `FeedList`, we encapsulate all data loading and high-level state in one place. This component doesn’t contain detailed markup of posts; it simply orchestrates fetching and listing.

### PostCard Component

`PostCard` represents an individual post in the feed. It is responsible for displaying all the post’s details and actions in the card UI. Each `PostCard` receives a `post` object prop (with fields like title, content, author, etc.) and possibly information about the current user’s vote on it. Key elements of `PostCard`:

* **Structure & Content:** The component will render a card (could be a `<article>` or `<div>` with a specific CSS class for styling). Inside, it displays:

  * The **upvote button** (using the `VoteButton` component) along with the current upvote count. This is usually on the left side of the card, styled as an icon and number.
  * The **title** of the post (likely as a clickable link or simply bold text). It might be in an `<h3>` or similar heading element to maintain semantic structure.
  * A short **description/blurb** of the post (if provided), in a smaller font under the title.
  * The **author’s name** and **time since posted** – usually at the top of the card or just under the title. For example: “David Kim • 8 hours ago”. We can format the timestamp from `created_at` to a relative time string (using a utility or library) each time the component renders.
  * A list of **tags** associated with the post, displayed as small badges or pills. These tags (if any) are rendered below the description. For example, small `<span>` elements with a distinct background (like light grey) and text (e.g., “React”, “Tutorial”).
  * Action icons for **comments, sharing, and bookmarking** on the right or bottom of the card. For instance: a comment icon followed by the number of comments, a share icon (to copy link or share the post), and a bookmark icon (to save the post). These might be simply icons wrapped in buttons or links. In the MVP, these icons are mostly visual; the comment count is displayed but clicking the comment icon could either be a no-op or navigate to a comments view if available. The share icon could trigger a copy-link function, and the bookmark could save to a list (though these features can be stubbed initially).

* **Vote Integration:** `PostCard` uses the `VoteButton` component to handle upvoting. It will pass to `VoteButton` the post’s `id`, the current vote count, and whether the current user has upvoted it (e.g., `active=true/false`). It also passes a handler function to perform the vote action. Typically, the handler will call the appropriate API (via a React Query mutation) to record the vote and update the UI. We might also pass the QueryClient or an invalidate function down, but more cleanly, the mutation can be defined in a context or in the VoteButton itself using React Query hooks.

* **Styling:** The card will have a light background (in light mode) with a subtle shadow and rounded corners, as per the design. We’ll use CSS (or a CSS-in-JS / Tailwind) to achieve this. The layout could be a flexbox: for example, a flex row where the left part is the vote section (icon + number) and the right part is the main content. The right part can itself be a flex column for title, meta, etc. We will ensure proper spacing and alignment (e.g., author name and time could be a small gray text above or below the title). On hover or focus, the card might slightly highlight (e.g., increase shadow or change background) to indicate interactivity.

* **Accessibility:** The post title can be a link or button if it navigates somewhere (if posts link to an external URL or a detail page). If not, it can just be static text. The author and time text will be in a readable format (we may use a `<time>` element with a `datetime` attribute for machine-readability). Icons will have `aria-label` or `title` attributes if clickable (e.g., the bookmark icon could have `aria-label="Bookmark this post"`). The entire card is structured semantically (using headings for titles, list for tags, etc., as appropriate).

In summary, `PostCard` encapsulates the presentation of a single post’s data and delegates the vote interaction to the VoteButton. Multiple PostCards are rendered by FeedList to form the full feed.

### VoteButton Component

The `VoteButton` component is a focused component for the upvote arrow button. It displays the upvote icon (an upward arrow or triangle) and optionally the count. In some designs, the count might be separate text next to or below the icon – in our design, the number of votes is typically shown adjacent to the arrow (below it in the left gutter of the card). We might incorporate the count into this component or keep it separate. For flexibility, we can treat `VoteButton` as handling the icon and toggle state, and allow the parent to display the number. Alternatively, `VoteButton` can include the number itself. Key points:

* **Props:** Likely takes `count` (number of votes), `active` (boolean, whether the current user has upvoted this already), and an `onToggle` handler (function to call when clicked). It might also take an `disabled` prop in case the user cannot vote (e.g., not logged in).
* **Rendering:** Renders as a `<button>` element (to be keyboard focusable by default) containing an up-arrow icon (could be an SVG or icon font). We will style this button so that when `active` is true (user has upvoted), the icon (and possibly the count text) appears **orange** (as specified, using a bright color to indicate an active vote). When not active, the icon and text are a neutral color (gray). The number of votes can be rendered next to the icon or directly below it. In the provided design image, the arrow is above the number in a vertical arrangement. We can achieve that by using a bit of CSS (e.g., the button could be a column flex with the icon and a span for the number).
* **Interaction:** On click, it triggers the `onToggle` or appropriate mutation. Internally, we might use React Query’s `useMutation` within this component to call the vote API. For example:

  ```js
  const voteMutation = useMutation(toggleVoteForPost, {
      onSuccess: () => {
        // invalidate or refetch posts query
        queryClient.invalidateQueries(['posts']);
      }
  });
  ```

  Where `toggleVoteForPost(postId, active)` is a function that calls either POST or DELETE on `/api/posts/{id}/votes` depending on the intended action. If the component knows `active` state, it can decide to call the remove endpoint vs add endpoint. Alternatively, we can have separate mutation hooks for upvote and downvote.
* **Optimistic UI:** We want the UI to feel instant. We can optimistically update the UI by toggling the state locally and adjusting the count before the server responds. For instance, if the user clicks upvote (active goes from false to true), we immediately highlight the button and increment the displayed count by 1. The mutation then runs in background; if it succeeds, we confirm state (and likely refetch the authoritative data). If it fails (network or server error), we revert the UI state and show an error message. React Query makes this easy by providing optimistic update patterns. However, even without explicit optimism, our invalidation and refetch will happen so quickly that the change will seem almost real-time (for MVP, either approach is acceptable).
* **Accessibility:** The button will have `aria-pressed` attribute bound to the `active` state (this is appropriate for toggle buttons to inform screen readers of the pressed state) and an `aria-label`. The label should reflect the action, e.g. `"Upvote this post"` when not yet upvoted, and `"Remove upvote from this post"` when currently upvoted. This way a screen reader user knows what the button will do. We also ensure the button can be focused by keyboard (it’s a native `<button>`, so that’s handled). The icon itself can be an `<svg>` with `aria-hidden="true"` (so the screen reader reads the label, not the word "up arrow"). The vote count next to it can be read as plain text.
* **State visuals:** In addition to color change, we might give a slight animation on click (for example, a brief enlarge-shrink effect or a fade) to show the feedback. This isn’t required, but it can enhance the feel. The orange color chosen should meet contrast requirements on both light and dark backgrounds for visibility.

The `VoteButton` isolates all vote toggling logic. This means our `PostCard` doesn’t need to know the details of API calls – it just knows if it’s active and how many votes, and leaves the rest to `VoteButton`. The separation also allows potential reuse (if the same voting component is needed elsewhere, or if we want to change how voting works in one place).

With these components, the front-end structure will be roughly: a page or layout that includes a `<FeedList />` (and possibly a header), and within FeedList it renders multiple `<PostCard />`, each containing a `<VoteButton />` among other elements. This modular breakdown corresponds to the CGSamplePlugin’s approach of keeping components focused and state management (data fetching, etc.) in the appropriate places.

## State Management and Real-Time Updates with React Query

We leverage **React Query (TanStack Query)** to manage server state on the client, which greatly simplifies data fetching, caching, and real-time updates for our voting feed. The plugin uses React Query both for retrieving the list of posts and for handling vote mutations, allowing us to simulate real-time updates without needing a WebSocket.

* **Data Fetching with useQuery:** The `FeedList` (or similar top-level component) calls `useQuery` to fetch posts from `/api/posts`. We might use: `useQuery(['posts', currentUserId], fetchPosts)` – including the user in the query key if the request differs for logged-in users. The `fetchPosts` function will call the API and return the data. React Query caches this data, so if the user navigates away and back, it can show cached posts instantly and then refresh in the background if needed. We will set an appropriate **stale time** (maybe a short stale time, e.g. a few seconds to a minute) to ensure the data stays fresh but not refetch constantly. By default, React Query will also refetch on window focus, so if the user leaves and comes back, they get updated info. This behavior gives a near real-time feel as well.

* **Vote Mutations with useMutation:** The `VoteButton` uses `useMutation` for the vote toggle actions. We define two mutation functions: one for upvote (POST) and one for remove (DELETE), or a single toggle function that checks the current state. When the user clicks, we call `mutate(postId)` for the appropriate mutation. React Query allows us to perform an **optimistic update** – for example, we can immediately increment or decrement the vote count in the UI by updating the cached posts data before the network call completes. However, even if we don’t implement optimism at first, we will call `queryClient.invalidateQueries(['posts'])` on success of the mutation. This explicit invalidation forces the posts query to refetch the latest data from the server. The moment the mutation succeeds, the cached posts list is marked stale and refetched; the UI will then re-render with the updated vote counts and resorted order. This approach ensures the UI reflects the authoritative server state and that the ordering by upvotes is correct after each action. According to React Query’s documentation, using `invalidateQueries` is a common strategy to keep data in sync after a user action, guaranteeing the user sees the latest state from the server.

* **Instant Reordering:** Because our API returns posts already sorted, a refetch after voting will return the posts in the new correct order. For example, if a post’s upvote count increased and now exceeds the one above it, the refetched list will come back with the post moved up. The UI will then automatically render in the new order. This happens very quickly (a small network call), so the user perceives it almost in real-time. In addition, React Query’s state update is seamless, avoiding a full page reload – just the component updates. If needed, we could add a slight delay or loading state on the specific post card during the update to indicate something changed, but often it’s fast enough not to need it.

* **Cache & Persistence:** The user’s vote state (which posts they voted) is inherently part of the posts data (via the `userHasUpvoted` flags). When the page reloads, React Query will fetch fresh data (or use cached data if still valid). Because we rely on the server to indicate which posts are upvoted by the user, the upvote state will be correctly preserved on reload. Additionally, if the user navigates within the plugin (if there were multiple pages) and returns, the cached data would preserve that state until a refetch occurs. We can configure React Query’s cache time if we want to keep data longer.

* **No WebSockets Needed:** This design avoids the complexity of real-time sockets by using quick refetch and the fact that each user’s own actions are immediately reflected. If two users vote at the same time, one user won’t see the other’s vote count change until a refetch is triggered (which might happen on focus or some interval). We could enhance by adding a periodic refetch (for example, React Query’s `refetchInterval` option to pull new data every, say, 30 seconds to update counts). But for MVP, manual actions and focus-based refetch are likely enough. The “simulate real-time by cache expiration” essentially means using React Query’s automatic invalidation and refresh to mimic real-time updates without persistent connections.

Overall, React Query greatly simplifies keeping the UI in sync with the server. It handles caching and background updates so that the feed remains up-to-date. For instance, when a mutation succeeds and calls invalidate, *“React Query provides functions like `invalidateQueries` to force a refetch when necessary, ensuring that your app reflects the latest data.”*. This approach aligns with modern best practices and avoids manual state management of lists.

## Authentication & Common Ground Integration

Authentication in this plugin is entirely handled by **Common Ground’s context** – we do not implement a separate login or user management. We strictly use the Common Ground auth model provided to plugins, following the patterns from the CGSamplePlugin and the official CG plugin library. This ensures seamless integration: if a user is logged into Common Ground and has granted the plugin necessary permissions, the plugin can identify the user and allow actions; if not, the plugin will prompt for login via Common Ground.

**Common Ground Plugin Context:** Common Ground loads community plugins inside an **iframe** within the main app. Through this iframe-based integration, the plugin can communicate with the parent Common Ground app using the Common Ground Plugin SDK (JavaScript library). According to Common Ground’s documentation, plugins operate in a sandbox and use a secure message-passing interface to request data or actions from the platform. Each plugin is issued a public/private key pair when created; these keys are used to sign requests so that Common Ground can trust that requests from the iframe are legitimate (and not tampered with).

In our implementation:

* **Initializing the Plugin SDK:** In the Next.js frontend (likely in a top-level component or a custom React context provider), we will initialize the Common Ground plugin client library (`@common-ground-dao/cg-plugin-lib`). For example, upon app load we retrieve the `iframeUid` (passed as a URL query param when Common Ground embeds the plugin) and call `CgPluginLib.initialize(iframeUid, "/api/sign", PUBLIC_KEY)`. Here, `"/api/sign"` is the route in our app that will handle signing, and `PUBLIC_KEY` is our plugin’s public key (likely stored in an environment variable or config, obtained from plugin setup in CG). The `CgPluginLib.initialize` returns an instance that we can use to call Common Ground APIs. We will store this instance (perhaps in React context or a singleton) for use throughout the app. After initialization, the plugin library knows our identity and can handle encryption/signing behind the scenes for each request to CG.

* **Obtaining Current User Info:** Once the CG plugin client is ready, we can request the current user’s information from Common Ground. The CG SDK likely provides a method or property to get the current authenticated user (for example, `cgPlugin.getCurrentUser()` or a similar function). This would trigger a secure message to Common Ground asking “who is the user viewing this plugin?”. Common Ground should reply with the user’s identifier and possibly profile data, provided the user has authorized the plugin to access that info. We will likely need to ensure the plugin’s manifest (on the Common Ground side) declares a permission to read basic profile info (this would be a “mandatory permission” since without it we can’t function). Assuming permission is granted, the plugin receives the user’s ID (and perhaps username/avatar). We can then use this ID in our application. For example, we might set a state or context like `currentUser = { cg_user_id: "...", display_name: "...", ... }`. If the user is not logged in to Common Ground or hasn’t authorized the plugin, the `getCurrentUser` might return null or error – in that case, we know the user is unauthenticated for our purposes.

* **Storing/Using User Identity:** When we have the `cg_user_id` from the above step, we will check our local `users` table for a matching record. If it’s the first time we see this user, we will create a new `users` entry (populate `cg_user_id`, `display_name`, etc.). If it exists, we could update any changed info (e.g., maybe the user changed their display name on Common Ground since last time). This ensures our database is aware of the user. We do not ask the user for any credentials – we trust the Common Ground context completely. For subsequent API calls from the frontend to our backend (like voting), we need a way to convey that user identity securely. Because the plugin runs in the user’s browser, we have to be careful: we don’t want a malicious user to spoof someone else’s ID in an API call. There are a couple of strategies:

  * **Approach 1: Session Token** – Upon initialization (after getting user info), our plugin’s frontend could call an endpoint like `/api/auth/me` with the CG user info, and our server could respond with a signed session (e.g., a JWT or a secure HttpOnly cookie containing the user’s ID). This way, on future requests (like vote actions), the cookie is automatically sent and the server can trust it to identify the user (since it’s signed). Essentially, we establish a session tied to the Common Ground user. This is similar to how a standard app would create a session after OAuth login. The plugin’s private key might also be used here to verify the call if needed. With this, our API routes can simply read the user from the session and proceed.
  * **Approach 2: Client-Side Include + Verification** – Alternatively, the frontend can include the `cg_user_id` in each request (e.g., as a header or part of the request body), and the server can cross-verify it by querying the Common Ground backend via the plugin SDK. For example, if a request comes in with `userId=X` and a plugin-signed token, the server might ask Common Ground “is user X currently the one using the plugin iframe token Y?” However, this is more complex and likely not needed if we trust the session established.

  For MVP, we will implement a **simplified session approach**: after obtaining the user, we set a cookie identifying the user (signed to prevent tampering). Then on each API call (vote, etc.), we check that cookie. This avoids sending raw user IDs on every request and is easier to manage. The Common Ground keys ensure the plugin itself is trusted, and our own session ensures the user identity is consistent.

* **Enforcing Auth on Actions:** The front-end will disable or hide interactive elements if no user is logged in. For example, if `currentUser` is null (meaning the plugin couldn’t get a user – perhaps the user is not signed in to Common Ground), the `VoteButton` will be rendered in a disabled state (no hover, no click). We might also overlay a message or a login prompt. Since the plugin is inside Common Ground, the login prompt could be a message like “Please sign in to Common Ground to vote.” Common Ground might automatically show a sign-in screen if the user tries to access the plugin while not logged in – this depends on platform behavior. But in our UI, we will handle the case gracefully by guiding the user to log in. One possible enhancement is to use the Common Ground SDK to trigger a login flow – for instance, if the SDK has a method like `CgPluginLib.authenticate()` or if navigation to a login page is possible. In absence of that, a simple message or link is fine.

* **Using CG Backend Data:** The plugin might occasionally need to fetch additional data from Common Ground (e.g., to get a user’s profile or community info). Using the initialized `CgPluginLib` instance, we can call various methods. For example, there might be an API like `cgPluginLib.getUserProfile(userId)` to get more info on a user. If our `users` table lacks some info like the display name or avatar, we could call that for each new user encountered. This call would go from the plugin frontend -> our `/api/sign` -> CG backend and back, using the secure channel. This way, we rely on CG as the source of truth for user profiles and don’t have to collect that info via separate means. (This is speculative as we assume the CG SDK provides such methods or a generic API call mechanism.)

* **Following the CGSamplePlugin patterns:** We mirror the structure from the example plugin. For instance, in CGSamplePlugin, they likely set up the plugin keys in environment variables, call `CgPluginLib.initialize` on the client, define the `/api/sign` route on the server, and perhaps use a React context provider to pass down the plugin instance or user info. We will do the same. Additionally, a “mature” plugin example may have established a clear separation of concerns: one part handling integration (auth, context) and another handling application logic. We ensure that we do not bypass or shortcut the Common Ground auth (e.g., not creating a separate username/password or using localStorage hacks). Our plugin’s security will depend on Common Ground’s provided JWTs or keys. If CG issues a JWT for the user, we would validate that on the server for each request. If not, our trust is on the session as described.

* **Permissions:** On Common Ground’s side, when setting up the plugin, we’ll configure that it requires certain mandatory permissions – likely “Access user basic profile (username, avatar)” and perhaps “Post on behalf of user to plugin’s database” (the latter is conceptual; CG might not granularly control that). The user will have to accept these when they start the plugin. This process ensures the user is aware the plugin will know who they are. Since voting is a basic community action, it should be acceptable.

In summary, **only authenticated Common Ground users can vote**, as required. If unauthenticated, the plugin will not have a current user context and thus will block voting actions. The integration with Common Ground’s context is done via the official CG plugin libraries: we initialize the plugin in the iframe and use the provided messaging system and keys to handle all requests to Common Ground securely. By doing so, every request is cryptographically signed and verified, and our plugin backend only needs to focus on its own logic (storing posts/votes), not on validating Common Ground credentials (the plugin infrastructure does that). This approach follows Common Ground’s recommended usage and ensures that our plugin *“handles all the complexity of request signing”* through the provided library. We avoid any separate login UI, keeping user experience seamless – if you have access to the community on Common Ground, you can use the plugin with your existing session.

## User Interface & UX Considerations

&#x20;*Example UI design of the “Community Posts” feed within the plugin, showing post cards sorted by upvotes. Each card displays an upvote arrow with count, the author’s name and post time, the post title and description, tags, and icons for comments (with count), share, and bookmark.*

The plugin’s interface follows a modern, clean design to match Common Ground’s style. The focus is on readability and ease of interaction. Key UI/UX points include the visual design of post cards, responsive layout adjustments, dark mode styling, and accessibility for all users.

Each **post card** in the feed is a distinct panel (white or dark grey background depending on theme, with subtle drop shadow and rounded corners). The content is organized for quick scanning:

* The **header of the card** typically shows the author’s display picture or initials in a small circle, the author’s name in bold, and the time since posted in a lighter font (for example, “Maya Patel • 6 hours ago”). This gives context on who posted and recency.
* The **title** of the post is prominently displayed (larger font, bold). It might be truncated if too long, with an ellipsis to keep the card height reasonable. If the plugin supports clicking the title (to view details or an external link), it will be made an interactive element with appropriate hover style.
* The **blurb/description** follows in normal text, providing more info about the post content. This is kept to a few lines for brevity. If it’s too long, we may truncate or limit the number of characters stored.
* The **tags** are presented as pill-shaped labels below the description. For example, a post might have tags like “CSS” “Layout” “Tutorial” as shown in the design. These are styled with a slightly contrasting background (light grey in light mode, or a slightly brighter grey in dark mode) and smaller font. They help categorize content and can be skipped by users who aren’t interested in them, so visually they are subtle.
* On the **left side of the card**, we have the upvote control (the arrow and number). This is separated visually – often enclosed in a light box or aligned to the left edge. The number of votes is displayed either below or beside the arrow. This number updates immediately when votes change. The arrow icon changes color when the user has voted (orange in light theme, and perhaps a teal or orange in dark theme as well, making sure it’s visible on dark background).
* On the **right side/bottom of the card**, action icons are displayed: a comment icon followed by the comment count, a share icon, and a bookmark icon. These icons are usually represented by familiar symbols (e.g., a speech bubble for comments, a curved arrow or external share symbol for share, and a bookmark flag icon). For now, these actions are mostly visual cues:

  * The **comment count** is shown to indicate activity. (If we integrate with a comment system, clicking it could open a comments section. In MVP it might do nothing or navigate to Common Ground’s thread if one exists.)
  * The **share icon** on click could copy the post link to clipboard or open the browser’s share dialog (on mobile). We can implement a simple copy-to-clipboard with a tooltip like “Link copied!” as feedback.
  * The **bookmark icon** would allow users to save the post to a personal list. Implementing bookmarks might require additional backend storage per user. As an MVP, we might not implement actual persistence for bookmarks, but include the icon for future or simply toggle its appearance. If not functional, we ensure it’s not misleading (maybe disabled or with a “coming soon” tooltip).
* **Global UI elements:** At the top of the page, we display a title or header, e.g., “Community Posts – Discover and upvote the best content from our community,” as shown in the design. There is also a sub-button indicating sorting mode (“Sorted by Most Upvoted”). In MVP, that sorting is fixed (we always sort by upvotes), but we include the UI element to match the design. If we planned to allow sorting options (e.g., by newest or by trending), that could be a dropdown or toggle in the future.

The design is implemented with responsiveness and accessibility from the start:

### Accessibility

We adhere to WCAG accessibility guidelines to ensure the plugin can be used by as many people as possible, including those using keyboard navigation or screen readers:

* **Keyboard Navigation:** All interactive controls (vote buttons, share, bookmark, potentially the post title if clickable) are reachable via `Tab` key and operable with Enter/Space. We use semantic HTML elements (`<button>`, `<a>`) so that this is mostly handled by default. We also manage focus outlines – ensuring that focused buttons are visibly highlighted (using CSS `:focus` styles, without removing the outline unless replaced by an equivalent style).
* **Aria Labels and Roles:** The upvote button, as described, uses `aria-pressed` to indicate on/off state. It also has an `aria-label` that changes based on state (e.g., “Upvote post” vs “Remove upvote”). The comment, share, and bookmark icons (if they are buttons) will have `aria-label="Open comments"` or `"Share post"`, `"Bookmark post"`, respectively. If they are purely decorative in MVP (non-functional), we might mark them as `aria-hidden="true"` or remove them from tab order to avoid confusion. The post’s time text can be inside a `<time>` element with `datetime` attribute for screen readers to know the exact time.
* **Headings and Landmarks:** We likely wrap the feed in a main landmark (`<main>`). The list of posts could be an unordered list (`<ul>`) with each `PostCard` as an `<li>`, or simply a series of article elements. Using a list semantics might help screen reader users understand the number of posts. Each post title can be a heading (like an `<h2>` or `<h3>`). However, since this is inside an app, we manage heading levels carefully not to break the hierarchy of the overall page (the plugin itself might be a part of a bigger page in Common Ground).
* **Color Contrast:** We will choose text and background colors that meet contrast guidelines (e.g., the gray text for time and the orange for upvote icon against white have sufficient contrast). In dark mode, ensuring the orange or any highlight color still pops on dark backgrounds is important. If needed, we adjust the shade.
* **Feedback and States:** If an action (like voting or sharing) occurs, we provide feedback. For example, if share copies a link, we can briefly show a message (and for screen reader, we could use an `aria-live` region to announce "Link copied to clipboard"). For voting, since the change is immediately reflected in the count and button state, that itself is feedback. On error (say a vote fails due to network), we might display an error toast or message (“Vote failed, please try again”), and ensure that is announced to screen readers (using `role="alert"`).

By building with accessibility in mind, we create a plugin that all community members can interact with, not just those using a mouse on a desktop.

### Responsive Design

The plugin’s layout will adapt to different screen sizes, such as mobile phones, tablets, and desktop monitors:

* **Mobile (small screens):** The feed container will likely be full-width on mobile (with perhaps a small padding). Each post card will stack its elements vertically more compactly. For example, the upvote arrow and count may sit inline with the author and title on extremely narrow screens or we might shrink the spacing. The text will wrap as needed. We ensure that the number of votes and comment count icons don’t overflow. Possibly, on very narrow screens, we might hide the description blurb for a more compact view, or limit it to one line, to avoid very tall cards. All buttons remain touch-friendly (we ensure a minimum touch target size, e.g. 44px).
* **Desktop (large screens):** We center the content with a maximum width (maybe around 800px – as in the image – to keep line lengths readable). On large screens, the design in the image shows the cards centered in the middle with space on sides, which we’ll replicate. Everything is already nicely spaced out for desktop. We might also implement a multi-column layout if the design called for it, but given the image, we stick to a single column feed for simplicity.
* **Flexbox/Grid:** We use CSS Flexbox or Grid to arrange elements. For instance, the `PostCard` can be a flex container: the upvote section on the left could be one flex item (with a fixed width, say 40px), and the rest of the content as another flex item (which itself is a column flex). This way, on smaller screens, we could reorder or wrap. If needed, we could have the meta info (author name and time) in a row that wraps under the title on narrow widths.
* **Testing breakpoints:** We’ll define CSS breakpoints (e.g., at 600px or so) to adjust font sizes and spacing. For example, on mobile, maybe the title font is slightly smaller, and the icons might not show labels (if we had any labels). We ensure no critical information is lost; mostly it’s about spacing and flow.

By making the design responsive, the plugin will be comfortable to use on a phone within the Common Ground mobile app or in a desktop web browser alike.

### Dark Mode & Theming

Common Ground likely has an overall theme or dark mode setting that the plugin should honor. We implement a **dark mode** toggle in our plugin (and/or automatically respond to the parent’s theme if an API is available for that). The requirements call for a gradient background in both modes and a toggle control:

* **Theme Toggle:** We can add a toggle (perhaps a simple switch or button in the top-right of the plugin UI) allowing the user to switch between Light and Dark themes manually. Alternatively, if Common Ground passes a preferred theme (some platforms pass a query or context), we can default to that and allow override. Implementation can use CSS classes (e.g., adding a `.dark` class to the `<html>` or `<body>` of our iframe) or a library like `next-themes` to manage theme state.
* **Light vs Dark Styles:** In light mode, as shown, the background is a very light grey with a subtle top-bottom gradient, and cards are white. In dark mode, we will invert this: the background could be a dark navy or charcoal with a slight gradient (for visual interest), and the post cards would be a darker grey (not pure black, to maintain contrast with text). Text will become light (white or off-white). The orange highlight for upvote likely works on dark (orange on dark is high contrast), but we might adjust it if needed (maybe a slightly lighter or more yellow-orange if the original is too red for dark).
* **CSS Implementation:** We can use CSS variables for colors. Define a set for light and a set for dark. For example: `--bg-color`, `--card-bg`, `--text-color`, `--muted-text-color`, `--accent-color` (for the upvote orange), etc. In light mode, `--bg-color: #F7F9FC` (just as an example of a light bluish grey), `--card-bg: #FFFFFF`, `--text-color: #000000`, `--muted-text-color: #767676`, `--accent-color: #FF6600` (an orange). In dark mode, `--bg-color: #1A1A1A` (dark grey), `--card-bg: #2A2A2A`, `--text-color: #FFFFFF`, `--muted-text-color: #AAAAAA`, `--accent-color: #FF7700` (maybe a slightly brighter orange). The gradient can be defined using these colors (for example, background: `linear-gradient(to bottom, #F7F9FC 0%, #FFFFFF 100%)` in light, and a similar subtle variation in dark like `linear-gradient(to bottom, #1A1A1A 0%, #212121 100%)`).
* **Apply Gradient:** We’ll apply the gradient to the body or main container. The gradient provides a nice visual depth behind the white cards. It should be subtle enough not to distract.
* **Persisting Theme:** If the user toggles dark/light in the plugin, we can store that preference (e.g., in `localStorage` or a cookie within the iframe domain) so that it stays when they come back. Alternatively, follow system preference (we can use `prefers-color-scheme` CSS media query to default).
* **Common Ground Integration:** If Common Ground has a global dark mode toggle, ideally the plugin would detect it. If the CG plugin API offers theme info, we would use that. For now, we implement our own toggle to meet the requirement explicitly.

By providing both light and dark themes, we ensure the plugin feels native in either mode and user comfort is maximized in low-light conditions. The use of gradients and modern styling aligns with the design aesthetic Common Ground expects.

---

In conclusion, this specification covers the end-to-end implementation details for the voting plugin: from database design and API structure to frontend components and user experience considerations. By using Next.js and React Query for a responsive, dynamic UI and by strictly adhering to Common Ground’s plugin architecture for auth and data access, we create a plugin that is **scalable, secure, and user-friendly**. This approach is backed by Common Ground’s documentation and best practices – the plugin operates within a secure iframe environment and communicates with Common Ground’s backend through signed requests, and leverages React’s ecosystem for an interactive real-time feel on the client side. Once implemented, community members will be able to discover content and collectively curate it via upvotes, all within the familiar Common Ground interface, with immediate feedback and without compromising on accessibility or performance.
